# -*- coding: utf-8 -*-
"""2018A7PS0157G_Saurabh.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12WCAM0LY4M6K3tmYNv4uE5cMoCJxTpJL
"""

import random
import matplotlib.pyplot as plt 

inf = 100

cities = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]

adjacency_mat = [
        [0, inf, inf, inf, inf, inf, 0.15, inf, inf, 0.20, inf, 0.12, inf, inf],
        [inf, 0, inf, inf, inf, inf, inf, 0.19, 0.40, inf, inf, inf, inf, 0.13],
        [inf, inf, 0, 0.60, 0.22, 0.40, inf, inf, 0.20, inf, inf, inf, inf, inf],
        [inf, inf, 0.60, 0, inf, 0.21, inf, inf, inf, inf, 0.30, inf, inf, inf],
        [inf, inf, 0.22, inf, 0, inf, inf, inf, 0.18, inf, inf, inf, inf, inf],
        [inf, inf, 0.40, 0.21, inf, 0, inf, inf, inf, inf, 0.37, 0.60, 0.26, 0.90],
        [0.15, inf, inf, inf, inf, inf, 0, inf, inf, inf, 0.55, 0.18, inf, inf],
        [inf, 0.19, inf, inf, inf, inf, inf, 0, inf, 0.56, inf, inf, inf, 0.17],
        [inf, 0.40, 0.20, inf, 0.18, inf, inf, inf, 0, inf, inf, inf, inf, 0.60],
        [0.20, inf, inf, inf, inf, inf, inf, 0.56, inf, 0, inf, 0.16, inf, 0.50],
        [inf, inf, inf, 0.30, inf, 0.37, 0.55, inf, inf, inf, 0, inf, 0.24, inf],
        [0.12, inf, inf, inf, inf, 0.60, 0.18, inf, inf, 0.16, inf, 0, 0.40, inf],
        [inf, inf, inf, inf, inf, 0.26, inf, inf, inf, inf, 0.24, 0.40, 0, inf],
        [inf, 0.13, inf, inf, inf, 0.90, inf, 0.17, 0.60, 0.50, inf, inf, inf, 0],
    ]

class TSP(object):
    MUTATION_RATE = 0.5
    def __init__(self, parents=None):
        self._fitness = None
        self._probability = None
        if parents == None:
            self.state = [0,1,2,3,4,5,6,7,8,9,10,11,12,13]    # initial state of the population
        else:
            parent1 = parents[0]
            parent2 = parents[1]
            self.state = self.crossover(parent1, parent2)
            self.mutate()

    def fitness(self):
        if not self._fitness:
            state = self.state
            cost = 0
            for i in range(len(state) - 1):
                cost += adjacency_mat[state[i]][state[i + 1]]
            cost += adjacency_mat[state[0]][state[len(state)-1]]
            self._fitness = 1/cost
        return self._fitness

    def probability(self, population):
        if not self._probability:
            self._probability = self.fitness() / sum([x.fitness() for x in population])
        return self._probability

    def crossover(self, parent1, parent2):
        crossover_index1 = random.randint(0,13)
        crossover_index2 = random.randint(0,13)
        left = min(crossover_index1,crossover_index2)
        right = max(crossover_index1,crossover_index2)
        sub_child1 = parent1.state[left:right+1]
        sub_child2 = [i for i in parent2.state if i not in sub_child1]
        child = sub_child2[:left] + sub_child1 + sub_child2[left:left+13-right]
        return child

    def mutate(self):
        a = random.randint(0,13)
        b = random.randint(0,13)
        while(a==b):
            b = random.randint(0,13)
        if random.random() <= TSP.MUTATION_RATE:
            temp = self.state[a]
            self.state[a] = self.state[b]
            self.state[b] = temp

class EightQueens(object):
    MUTATION_RATE = 0.05
    def __init__(self, parents=None):
        self._fitness = None
        self._probability = None
        if parents == None:
            self.state = [1,1,1,1,1,1,1,1]    # initial state of the population
        else:
            parent1 = parents[0]
            parent2 = parents[1]
            self.state = self.crossover(parent1, parent2)
            self.mutate()

    def fitness(self):
        if not self._fitness:
            state = self.state
            row_collisions = sum([state.count(col)-1 for col in state])/2   # counting collisions in same row

            diagonal_collisions = 0
            for i, col in enumerate(state):
                for j, diagonal in enumerate(state):
                    mod = abs(i-j)
                    if mod > 0: 
                        if diagonal + mod == col or diagonal - mod == col:
                            diagonal_collisions += 1
            diagonal_collisions /= 2 
            self._fitness = 1 + int(28 - (row_collisions + diagonal_collisions))
        return self._fitness

    def probability(self, population):
        if not self._probability:
            self._probability = self.fitness() / sum([x.fitness() for x in population])
        return self._probability

    def crossover(self, parent1, parent2):
        crossover_index1 = random.randint(0,7)
        crossover_index2 = random.randint(0,7)
        left = min(crossover_index1,crossover_index2)
        right = max(crossover_index1,crossover_index2)
        sub_child1 = parent1.state[left:right+1]
        sub_child2 = parent2.state
        for i in sub_child1:
            if(sub_child2.count(i)>0):
                sub_child2.remove(i)
                parent2.state.insert(len(parent2.state), i)
        child = sub_child2[:left] + sub_child1 + sub_child2[left:left+7-right]
        return child

    def mutate(self):
        for i in range(len(self.state)):
            if random.random() < EightQueens.MUTATION_RATE:
                self.state[i] = random.randint(1,8)


def drawState(state):
    board = []
    row = []
    for j in range(8):
        for col in state:        
            if col == j+1:
                row.append("Q")
            else:
                row.append("-")
        board.append(row)
        row = []
    for i in range(8): 
        for j in range(8): 
            print (board[i][j], end = " ") 
        print() 

def pickRandomByProbability(populationByProbability):
    i = 0
    selectedState = None
    while selectedState == None:
        current = populationByProbability[i]
        if current[0] >= random.random():
            return current[1]
        if i+1 >= len(populationByProbability):
            i = 0
        else:
            i += 1

def generateNextPopulation1(population, n):
    newPopulation = []
    while len(newPopulation) < n:
        populationByProbability = [(x.probability(population), x) for x in population]
        parent1 = pickRandomByProbability(populationByProbability)
        populationByProbability = [x for x in populationByProbability if x[1] != parent1]
        parent2 = pickRandomByProbability(populationByProbability)
        child1 = EightQueens((parent1, parent2))
        child2 = EightQueens((parent2, parent1))
        if child1.fitness() > child2.fitness() :
            newPopulation.append(child1)
        else:
            newPopulation.append(child2)
    return newPopulation

def EightQueens_main():
    populationSize = 200
    generation = 1
    best_fitness = []
    
    population = [EightQueens() for x in range(populationSize)]
    while not 29 in [x.fitness() for x in population]:
        best_fitness.append(max([x.fitness() for x in population]))
        print("generation %d Best fitness: %d" % (generation, max([x.fitness() for x in population])))
        population = generateNextPopulation1(population, populationSize)
        generation += 1
    best_fitness.append(max([x.fitness() for x in population]))
    print("generation %d Best fitness: %d" % (generation, max([x.fitness() for x in population])))
    generation += 1
    for x in population:
        if x.fitness() == 29:
            print(x.state)
            drawState(x.state)
    plt.plot(range(1,generation), best_fitness)
    plt.xlabel("Number of Generations")
    plt.ylabel("Best Fitness Value")
    plt.title("Second Algorithm")
    plt.show()

def generateNextPopulation2(population, n):
    newPopulation = []
    while len(newPopulation) < n:
        populationByProbability = [(x.probability(population), x) for x in population]
        parent1 = pickRandomByProbability(populationByProbability)
        populationByProbability = [x for x in populationByProbability if x[1] != parent1]
        parent2 = pickRandomByProbability(populationByProbability)
        child1 = TSP((parent1, parent2))
        child2 = TSP((parent2, parent1))
        if child1.fitness() > child2.fitness() :
            newPopulation.append(child1)
        else:
            newPopulation.append(child2)
    return newPopulation


def TSP_main():
    populationSize = 200
    generation = 1
    best_fitness = []
    population = [TSP() for x in range(populationSize)]
    while generation < 1000 :
        best_fitness.append(1/max([x.fitness() for x in population]))
        print("generation %d Best fitness: %f" % (generation, 1/max([x.fitness() for x in population])))
        population = generateNextPopulation2(population, populationSize)
        generation += 1
    best_fitness.append(1/max([x.fitness() for x in population]))
    print("generation %d Best fitness: %f" % (generation, 1/max([x.fitness() for x in population])))
    generation += 1
    for x in population:
        if 1/x.fitness() == 1/max([x.fitness() for x in population]):
            print(x.state)
            break
    plt.plot(range(1,generation), best_fitness)
    plt.xlabel("Number of Generations")
    plt.ylabel("Best Fitness Value")
    plt.title("Second Algorithm")
    plt.show()

if __name__ == '__main__':
    print("Type 1 for 8-queens problem or type 2 for Travelling salesman problem")
    x = input()

    if x=="1":
        EightQueens_main()

    else:
        TSP_main()